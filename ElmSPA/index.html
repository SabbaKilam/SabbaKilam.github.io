<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width
		initial-scale=1 
		maximum-scale=1
		minimum-scale=1"			
	>
	<title>Single-Page Web Apps in ELM: Part One - Getting Started with a New Language</title>
	<link rel="stylesheet" href="style.css">
	<script src="prefixfree.js"></script>
	
</head>
<body>
	<div id="wrapper">
	<div id="header">

		<h4>Single-Page Web Apps in ELM<br/>Part One:<br/>Getting Started with<br/> a New Language</h4>
		<div style="color: white;  font-size: 0.75rem; text-align: left; font-weight: normal; text-shadow: 0 1px 0 black"><a href="https://www.linkedin.com/pulse/single-page-web-apps-elm-part-one-getting-started-new-kevin-greene" target="_blank" style="text-decoration: none;">From the original LinkedIn Blog by Kevin Greene &nbsp;&nbsp;<img src="img/KevinGreene.jpg" style="border-radius: 50%; width: 8%; top: 8rem; position: absolute"></a></div>

	</div>
	<br/><br/><br/><br/><br/>
Kevin Greene<br/>
Senior UI Engineer<br/>
<br/>
Other Posts in this Series:<br/>
&#x02022;&nbsp;<a href="https://www.linkedin.com/pulse/single-page-web-apps-elm-part-two-functional-routing-kevin-greene" target="_blank">Part Two - Functional Routing</a><br/>
&#x02022;&nbsp;<a href="https://www.linkedin.com/pulse/single-page-web-apps-elm-part-three-testing-structure-kevin-greene" target="_blank">Part Three - Testing and Structure</a><br/>
&#x02022;&nbsp;<a href="https://www.linkedin.com/pulse/single-page-web-apps-elm-part-four-side-effects-kevin-greene" target="_blank">Part Four - Side Effects</a><br/>
 <br/>
<strong>Introduction</strong><br/>
As the words "Part One" in the title should give away, this is the first in a series of posts about building single-page web apps in Elm. I think this will be a four part series, but that may change. The way I see it now, this series will take this form:<br/>
<br/>
Part one will introduce Elm, the Elm architecture and set up our project directory.<br/>
Part two will get into the architecture of our particular application and introduce routing in Elm.<br/>
Part three will be the most code-heavy of the series as we crank through most of our implementation. If this series becomes more than four parts, it'll be this part splitting up.<br/>
Part four will be refactor, clean-up and review.<br/>
As I write these I'll update the Github repo with branches corresponding to each part in the series. I also plan to publish one post a week until finished, but until it's done we won't know if I reach that goal.<br/>
<br/>
I am writing this series with the assumption that you are familiar with JavaScript and writing single-page apps in JavaScript. I am also assuming no particular familiarity with Elm. I am starting from that and building up to writing our application in Elm. I will often compare Elm to JavaScript and translate Elm code to JavaScript for illustration. There are other very good tutorials introducing Elm and the Elm architecture. I will often reference to those and provide many links. I will go through a quick introduction to the Elm language and architecture here, but this series is really about how you build the kind of complex web apps in Elm that you are used to writing in JavaScript.<br/>
<br/>
<strong>What is This Application you Speak Of?</strong><br/>
I want the application we write to be of enough complexity as to be a reasonable representation of the kind of code you would write for a production app, but obviously simple enough to complete in a relatively limited amount of time. With that in mind, we are going to write a simple blogging application. There will be a list view for browsing posts, a detail view for reading posts and an edit view for writing posts. We'll implement a few features that go a bit beyond the basics. We'll support auto-save. We'll support markdown. We'll support saved drafts. And we'll support off-line editing. We'll also implement some simple authentication for the edit view. First though, we need to learn what Elm is and how to use it.<br/>
<br/>
<br/>
<strong>So, What is Elm?</strong><br/>
Elm is a compile-to-JS language that has been around for a while, but has been getting more attention lately. The ideas it presents are interesting and its influence beyond its own community is rather astounding. Even if you are not familiar with Elm you have probably been influenced by Elm in some way, particularly if you are working with React. Redux and Cycle.js are attempts to bring the Elm Architecture to JavaScript. Elm code is very declarative and makes many problems much easier to reason.<br/>
<br/>
Elm is unique to other popular compile-to-JS languages in that it does not aim to make incremental improvements to JavaScript, to make JavaScript type-safe or to make JavaScript more concise. It is not JavaScript + something. It is something different entirely, a pure functional language designed for building front-end applications.<br/>
<br/>
There are several things a JavaScript developer may find to be a barrier when trying Elm for the first time. The first thing is the syntax. Elm fits under the umbrella of ML-family or ML-derivative languages. Which means the syntax is completely different than C-based languages you are most likely used to. Unless you are familiar with Standard ML, Haskell, OCaml, or some other language in that tree of programming languages, the syntax is going to be something new to you. I've seen this be very frustrating for some people. Even when you've switched between languages before syntax has likely been very similar. JavaScript, Java, C, Swift, php, Python... all look very similar. Your eyes are trained to a certain syntax when reading code.<br/>
<br/>
Just to get our feet wet, this is an add function written in JavaScript:<br/>
<div class="rubberPicture" style="background: url(img/FeetWetJS.png) no-repeat left; background-size: contain; width: 100%; padding-top: 18%" ></div>
<br/>
The same function in Elm:<br/>
<div class="rubberPicture" style="background: url(img/FeetWetElm.png) no-repeat left; background-size: contain; width: 100%; padding-top: 11%" ></div>
<br/>
Note: Elm is statically typed, but the type declaration is optional. Elm will infer types for you. However, the type declarations are great documentation and are considered good practice.<br/>
<br/>
Say goodbye to using parenthesis and commas to define function parameters. In Elm parameters (and arguments on invocation) are separated by spaces. Shouldn't we declare add to be a const or var? No, all data in Elm is immutable. Const by default.<br/>
<br/>
The other big thing that can be a barrier to people when trying Elm for the first time is that it is a pure functional language. You can't jQuery or AJAX anywhere you want. You can't even console.log anywhere you want. Your functions need to be stateless. They must return the same result for the same input. Functions are merely a mapping of some input to some output. This isn't a suggestion, or a good practice to follow most of the time. The compiler will enforce this. The outside world is dirty. You must be careful when you interact with it. Being able to produce side effects anywhere breaks the statelessness of our functions. This is a big change to how JavaScript works and will force you to carefully plan how to handle your application's side effects.<br/>
<br/>
If we're able to get through these barriers we'll find there is a lot to be offered by Elm. Because of its pure functional nature, and its excellent compiler, you are guaranteed to not have runtime exceptions. Wow, right? Because of the declarative nature of functional programming many complex implementations are reduced to one-line expressions.<br/>
<br/>
Even if we take a look and decide it's not for us. We are likely to come away from the experiment as better programmers as we will be forced to look at old problems through a new lens. This act of being forced to solve old problems in new ways should remind us that problem solving is a creative process. There are many ways to solve the same problem. Keep an open mind.<br/>
<br/>
<br/>
<strong>Setting up Your Elm Environment</strong><br/>
Before we get into how Elm code actually works, we need to set up our machines know about Elm code and how to deal with it. Everything you need is available in convenient installer form on the elm-lang website: <a href="http://elm-lang.org/" target="_blank">elm-lang.org.<br/><br/>
<div class="rubberPicture" style="background: url(img/SettingUpElm.png) no-repeat left; background-size: contain; width: 100%; padding-top: 50%" ></div>
</a>
<br/>
<br/>
The "try" link will take you to an online environment that will allow you to jump in and start playing with the language immediately. There's even some sample code for you to look at and play with. <br/>
<a href="http://elm-lang.org/try" target="_blank"><div class="rubberPicture" style="background: url(img/OnlineEditor.png) no-repeat left; background-size: contain; width: 100%; padding-top: 50%" ></div></a>
<br/>
The install link will guide you through choosing the correct installer for your OS. For this tutorial we are using version 0.17 of the Elm Platform. The Elm Platform is all of the dev tools you need for Elm bundled up nicely for you.<br/>
<a href="http://guide.elm-lang.org/get_started.html" target="_blank"><div class="rubberPicture" style="background: url(img/Install.png) no-repeat left; background-size: contain; width: 100%; padding-top: 26%" ></div></a>
<br/>
<br/>
<i>Note: You don't have to install Elm globally. You'll notice you can use NPM to install Elm. You can use this to install Elm locally in a project directory just as you would a JavaScript dependency.
</i>
<br/>
<br/>
Once installation is complete you will have a few new commands available to you globally through the terminal. Well, really you'll have one new command, "elm". The elm command doesn't do anything by itself. It is used to run other useful tools that were installed as part of the Elm Platform. To get started, open a terminal and type in "elm". Hit enter and you will see a message like this:<br/>
<div class="rubberPicture" style="background: url(img/ElmCommandLine.png) no-repeat left; background-size: contain; width: 100%; padding-top: 50%" ></div>
<br/>
<br/>
Okay, so, a sneak peak at what we can do. When we installed the Elm Platform we were given four tools: make, package, reactor and repl.<br/>
<br/>
<br/>
<strong>Time to Setup our Project</strong><br/>
We need a place to start writing some code, or this isn't going to make a whole lot of sense. There are two ways to proceed. You can clone the repo from my github link (<a href="https://github.com/kevinbgreene/elm-tutorial/tree/part-one" target="_blank">Elm Tutorial</a>) and just follow along, or you can do everything manually along with me here. The choice is yours. I will continue as if you are doing all these steps with me.<br/>
<br/>
<strong>Elm Package</strong><br/>
The first thing we need to do is make a directory for our new Elm project. Name it whatever you like. There are things I care about. This is not one of them. Once you have a new directory, navigate into that directory from the terminal. From here we are going to use the first of our Elm tools. Run "elm package install" from your terminal.<br/>
<br/>
<i>Note: If you are following from the git repo you should still run "elm package install" to download all dependencies.</i><br/>
<div class="rubberPicture" style="background: url(img/ElmPackageInstall.png) no-repeat left; background-size: contain; width: 100%; padding-top: 33%" ></div>
<br/>
<br/>
This is similar to running "npm install". This did a couple of things for you. First, the upgrade plan it asked you to approve was simply to download the core libraries for Elm. Yes, we will need those. These were downloaded into a new "elm-stuff" directory within your project directory. "elm-stuff" is analogous to "node_modules". Second, you are no doubt familiar with the package.json in your JavaScript projects. Elm has the very similar elm-package.json. It has the same primary purpose, manage dependencies, for our Elm project. This file was created for us during "elm package install". If the elm-package.json file already existed "elm package install" would not have overwritten it. Instead it would have looked to the existing file to know what dependencies to install. Open elm-package.json in your text editor. You should see something much like this:<br/>
<br/>
In the dependencies we have the core libraries we approved of in the upgrade plan. We also see the Elm version we are developing against. Other fields are there for you to update if you see fit.<br/>
<br/>
There is another package we are guaranteed to need, "elm-lang/html". Before moving along, let's install that: "elm package install elm-lang/html". This will install the latest version. If you want to install a specific version you would type the command like this: "elm package install elm-lang/html 1.1.0".<br/>
<br/>
This automatically updated our elm-package.json for us. We do not explicitly need "--save" or "--save-dev". We now have two dependencies.<br/>
<div class="rubberPicture" style="background: url(img/ElmPackageJson.png) no-repeat left; background-size: contain; width: 100%; padding-top: 40%" ></div>
<br/>
<br/>
<i>Note: Semantic versioning. The Elm package manager does a very good job of enforcing that no breaking API changes occur in an Elm package update without a major version bump. That is you shouldn't have to worry about some developer pushing a package update to version 2.0.5 as version 2.1.0 if there are breaking changes. The package manager will force them to bump to 3.x. That's why in our elm-package.json we have versions pinned to less than next major version bump. This should always be safe.</i><br/>
<br/>
<br/>
<strong>It's About Time for "Hello World"</strong><br/>
I want to see some code run. Do you want to see some code run? If I was writing this yesterday I would've probably been a little more motivated to not just use "hello world", but today I'm feeling lazy. The first thing we need to do is make our first Elm file. Make a new directory called "src". Inside of that create a new file called "Main.elm". It is convention in Elm to start file names with capital letters. Files equal modules in Elm. Do you mean I don't have to wrap everything in an IIFE to keep everything locally scoped? Yes, everything you write is scoped to the file you are in unless you explicitly export it. We'll cover module syntax later. Open your new file in a text editor and type this in. We'll learn what it all means soon enough, but for now trust the narrator.<br/><br/>
<div class="rubberPicture" style="background: url(img/ImportHtml.png) no-repeat left; background-size: contain; width: 100%; padding-top: 12%" ></div>
<br/>
<br/>
When we write JavaScript we can just run code anywhere. Everything is an entry point. Like most compiled languages, Elm has a "main" entry point. If your Elm app doesn't have a "main" entry point the compiler will complain. The main entry point can have a few acceptable types. Here our main entry point has the type "main : Html". It is just the HTML to display on the page. As we start building more complex applications our main entry point will have the type "main : Program".<br/>
<br/>
The HTML we build in Elm is actually virtual DOM, very similar to React. HTML in Elm will do the same virtual DOM diffing optimizations you see in React. In the case of our "hello world" application we are creating a virtual TextNode and assigning its contents to be the string "hello world".<br/>
<br/>
Elm Make<br/>
We shouldn't need more than one guess to figure out what this does. Elm make will compile our Elm code into JavaScript. If you run "elm make <path-to-source-file>" without any options you'll see something like this:<br/>
<div class="rubberPicture" style="background: url(img/ElmMake.png) no-repeat left; background-size: contain; width: 100%; padding-top: 12%" ></div>
<br/>
It generated an index.html file. All of the JavaScript is included in script tags on this HTML page. This is assuming you will be creating an Elm application that will be running by itself on the page and you will be assigning all CSS styles in your Elm code. For me, this is almost never the case. However, for our "hello world" app this is just fine. Open your new index.html in your favorite browser.<br/>
<div class="rubberPicture" style="background: url(img/HelloWorld.png) no-repeat left; background-size: contain; width: 100%; padding-top: 18%" ></div>
<br/>
Well, that was exciting. If you look at your index.html you'll find it's really a lot of stuff to produce this. The compiler includes all of the libraries needed to support our application. The way things are working now, every time we run "elm make" this index.html file will be overwritten. Usually I want to include some external CSS and sometimes I want to include some external JavaScript (Elm will play nice with JavaScript).<br/>
<br/>
If you don't want to generate an HTML page, or you want to generate an HTML page not named "index.html", you'll want to use the "--output" flag for the "elm make" command.<br/>
<br/>
<div class="rubberPicture" style="background: url(img/ElmMakeOutput.png) no-repeat left; background-size: contain; width: 100%; padding-top: 12%" ></div>
<br/>
You can tell elm-make to output either an HTML file or a JavaScript file. If you output a JavaScript file you'll need to make your own HTML page to support this file. You'll want something like this:<br/>
<div class="rubberPicture" style="background: url(img/HtmlTemplate.png) no-repeat left; background-size: contain; width: 100%; padding-top: 41%" ></div>
<br/>
We include the app.js file as we would any JavaScript file. The other thing we need to do is tell Elm how to launch our app. "Elm.Main.fullscreen();" tells Elm to load our app into the document body. You can also tell Elm to embed the app into some DOM node on the page. That would look like this:<br/>
<div class="rubberPicture" style="background: url(img/ElmDomNode.png) no-repeat left; background-size: contain; width: 100%; padding-top: 43%" ></div>
<br/>
This allows you to embed an Elm app into an existing website. You don't have to switch everything to Elm. It will play nicely with what you have already built.<br/>
<br/>
There is a third option. That is we want Elm to do some computations for us, but we don't want it to output anything directly to the screen. We would invoke this kind of Elm app with "Elm.Main.worker();".<br/>
<br/>
The application we are building in this tutorial will use the first option and create a fullscreen Elm application.<br/>
<br/>
<strong>Elm Reactor</strong><br/>
The third tool that the Elm Platform gave us was something called "reactor". What exactly is reactor? Reactor is a tool that will start a web server on your machine and recompile your code for you.<br/>
<div class="rubberPicture" style="background: url(img/ElmReactor.png) no-repeat left; background-size: contain; width: 100%; padding-top: 20%" ></div>
<br/>
Now if I navigate to localhost:8000 I get a page like this:<br/>
<div class="rubberPicture" style="background: url(img/ElmLocalhost.png) no-repeat left; background-size: contain; width: 100%; padding-top: 38%" ></div>
<br/>
<br/>
Ah cool, it's the contents of our directory with some info about our project. But what's so special about this? The magic happens when you use the "File Navigation" to navigate to an Elm file. Navigate to src/Main.elm. Yes, the file we made earlier. You should see "hello world" on the screen again. Your running Elm application. Now, go to the Main.elm file in your text editor and change the file in some way. A suggestion would be to make a non-breaking change, like change the text from "hello world" to something else. To keep with my creativity so far, I'm going with "hello world 2". If you then go back to your web browser and refresh the page you'll see your changes. Elm reactor recompiles our code on page refresh without us having to use "elm make". Sweet, this should make iterating on our code a little quicker.<br/>
<br/>
	<div id="endLink">(<a href="https://www.linkedin.com/pulse/single-page-web-apps-elm-part-one-getting-started-new-kevin-greene" target="_blank">continue reading at the original posting &#x02022;&nbsp;&#x02022;&nbsp;&#x02022;&nbsp; </a>)</div><br/><br/>

	</div><!-- END of wrapper div-->
<script src="script.js"></script>
</body>
</html>
